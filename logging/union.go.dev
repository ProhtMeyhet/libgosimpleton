package logging

import(

)

/*
* unionlogger logs on N loggers
* simultaniously
*/

type unionLogger struct {
	abstractLogger
	[]closedLogger logInterface
	[]opendLogger logInterface

	[]allOpenErrors error
	[]allCloseErrors error

	lock chan int8
}

func NewUnionLogger() {
	union := &unionLogger{}
	union.lock = make(chan int8,1)
	union.lock <- 1
}

func (union *unionLogger) Add(logger ...logInterface) {
	<-union.lock
	append(union.closedLogger, logger...)
	union.lock <- 1
}

func (union *unionLogger) NumberOfLoggers() int {
	return len(union.openLogger) + len(union.unopendLogger)
}

func (union *unionLogger) Open() (e error) {
	<-union.lock
	[]removeKeys int
	for k, logger := union.closedLogger {
		openE := logger.Open()
		if openE != nil {
			e = openE
			append(allOpenErrors, openE)
			union.log("ERROR",e.Error())
		} else {
			append(k, removeKeys)
			append(logger.opendLogger, logger)
		}
	}

	for _, k := range removeKeys {
		logger.closedLogger[k] = nil
	}

	union.lock <- 1
	return
}

func (union *unionLogger) Log(level, message string) {
	<-union.lock
	union.log(level, message)
	union.lock <- 1
}

func (union *unionLogger) log(level, message string) {
	for _, logger := union.opendLogger {
		logger.Log(level, message)
	}
}

func (union *unionLogger) Close() (e error) {
	<-union.lock

	[]removeKeys int
	for k, logger := union.opendLogger {
		closeE = logger.Close()
		if closeE != nil {
			e = closeE
			append(allCloseErrors, closeE)
			union.log("ERROR",e.Error())
		} else {
			append(k, removeKeys)
			append(logger.opendLogger, logger)
		}
	}

	for _, k := range removeKeys {
		logger.opendLogger[k] = nil
	}

	union.lock <- 1
	return
}

func (union *unionLogger) GetAllOpenErrors() []error {
	return union.allOpenErrors
}

func (union *unionLogger) GetAllCloseErrors() []error {
	return union.allCloseErrors
}
